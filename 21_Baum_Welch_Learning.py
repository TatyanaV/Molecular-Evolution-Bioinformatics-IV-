'''
Next
CODE CHALLENGE: Implement Baum-Welch Learning.
Input: A sequence of emitted symbols x = x1 . . . xn in an alphabet A, generated by a k-state HMM with
unknown transition and emission probabilities, initial Transition and Emission matrices and a number of iterations .
Output: A matrix of transition probabilities Transition and a matrix of emission probabilities Emission that
maximizes Pr(x) over all possible transition and emission matrices and over all hidden paths .

Extra Dataset

Sample Input:
10
--------
xzyyzyzyxy
--------
x	y	z
--------
A	B
--------
	A	B
A	0.019	0.981 
B	0.668	0.332 
--------
x	y	z
A	0.175	0.003	0.821 
B	0.196	0.512	0.293
Sample Output:
	A	B
A	0.000	1.000	
B	0.786	0.214	
--------
	x	y	z
A	0.242	0.000	0.758	
B	0.172	0.828	0.000
https://github.com/johnmerm/bioinfo/blob/e6a255a461ca83c58e56c83d4717bc13f8880c5d/src/main/java/bioinfo/hiv/viterbiLearning.py


'''


def letter_simple(path,x):
    cnt = len(path)
    return x[cnt-1]
	
def prod(itera):
    return reduce(lambda x,y:x*y,itera,1
	
def optimalPath(x,transitions,emissions,alphabet=['x','y','z'],symbols=['A','B'],letter_func = letter_simple,init_states=None):
    if init_states == None:
        init_states = symbols
    scores = {s:{e:(ev/len(symbols),[s]) for (e,ev) in emissions.items() if e[0]==s and e[1]==letter_func([s],x)} for s in init_states}
    scores = {s:max(v.values(),key=lambda x:x[0]) for (s,v) in scores.items()}
    
    for i in range (1,len(x)):
    
        
        states = {t for t in symbols for s in scores.keys() if (s,t) in transitions} 
        
        new_scores = {s:{t[0]:((scores[t[0]][0],tv,ev),scores[t[0]][1]) for (t,tv) in transitions.items() for (e,ev) in emissions.items() 
                         if t[0] in scores and e[1] == letter_func(scores[t[0]][1]+[s],x) and t[1]==s and e[0] == s
                         } for s in states }
        
        new_scores = {s:{tk:(prod(tv[0]),tv[1]+[s]) for (tk,tv) in v.items()}  for (s,v) in new_scores.items()}
        
        new_scores = {s:max(v.values(),key=lambda x:x[0]) for (s,v) in new_scores.items() if len(v.values())>1}
        
        
        scores = new_scores
        cand = max(scores.values())[1]
    return max(scores.values())[1]

	
	
def parameterEstimation(x,alphabet,path,symbols):
    trans = {}
    ems = {}
    for i in range(len(x)):
        p = path[i]
        a = x[i]
        
        if not p in ems: ems[p] = {}
        
        if a in ems[p]: ems[p][a] +=1
        else :ems[p][a] = 1
    
    sum_ems = {p:sum(v.values()) for (p,v) in ems.items()}
    norm_ems = {p:{vk:float(vv)/sum_ems[p] for (vk,vv) in v.items()} for (p,v) in ems.items()}
    
    for i in range(len(path)-1):
        _f = path[i]
        _t = path[i+1]
        
        if not _f in trans: trans[_f] = {}
        
        if _t in trans[_f]: trans[_f][_t] += 1
        else: trans[_f][_t] = 1
    
    sum_trans = {p:sum(v.values()) for (p,v) in trans.items()}
    norm_trans = {p:{vk:float(vv)/sum_trans[p] for (vk,vv) in v.items()} for (p,v) in trans.items()}
    
    trans_mat = [[norm_trans[_f][_t] if _t in norm_trans[_f] else 0 for _t in symbols]
                 if _f in norm_trans else [1./len(symbols) for _t in symbols] 
                 for _f in symbols] 
    ems_mat = [[norm_ems[_f][_t] if _t in norm_ems[_f] else 0 for _t in alphabet]
               if _f in norm_ems else [1./len(alphabet) for _t in alphabet] 
               for _f in symbols]
    
    return trans_mat,ems_mat	

#from markov import optimalPath
#from parameterEstimation import parameterEstimation
#from bioinfo.hiv.parameterEstimation import printMatrices
def printMatrices(trans_mat,ems_mat,symbols,alphabet):
    print ' \t'+'\t'.join(symbols)
    for i in range(len(symbols)):
        print symbols[i]+'\t'+'\t'.join([str(t) for t in 
                                       trans_mat[i]])
    print "--------"
    
    print ' \t'+'\t'.join(alphabet)
    for i in range(len(symbols)):
        print symbols[i]+'\t'+'\t'.join([str(t) for t in 
                                      ems_mat[i]])

									  
def viterbiLearning(iterations,x,alphabet,symbols,transition_mat,emission_mat):
    for iter in range(iterations):
        transitions = {(symbols[i],symbols[j]):transition_mat[i][j] for i in range(len(symbols)) for j in range(len(symbols)) }
        emissions = {(symbols[i],alphabet[j]):emission_mat[i][j] for i in range(len(symbols)) for j in range(len(alphabet)) }
        
        path = optimalPath(x, transitions, emissions, alphabet, symbols)
        
        transition_mat,emission_mat = parameterEstimation(x, alphabet, path, symbols)
    return transition_mat,emission_mat


def parseLines(lines):
    iterations = int(lines[0].strip())
    x = lines[2].strip()
    alphabet = lines[4].strip().split()
    symbols = lines[6].strip().split()
    tramat_lines = lines[9:9+len(symbols)]
    emismat_lines = lines[11+len(symbols):]
    
    tramat = [[float(l) for l in li.split()[1:]] for li in tramat_lines]
    emismat = [[float(l) for l in li.split()[1:]] for li in emismat_lines]
    
    return (iterations,x,alphabet,symbols,tramat,emismat)
	
def test_viterbiLearning():
    lines = [
             "100",
            "--------",
            "zyzxzxxxzz",
            "--------",
            "x y z",
            "--------",
            "A B",
            "--------",
            "    A    B",
            "A    0.599    0.401    ",
            "B    0.294    0.706    ",
            "--------",
            "    x    y    z",
            "A    0.424    0.367    0.209    ",
            "B    0.262    0.449    0.289"
        ]
    
    (iterations,x,alphabet,symbols,tramat,emismat) = parseLines(lines)
    tramat,emismat =  viterbiLearning(iterations,x,alphabet,symbols,tramat,emismat)
    
    printMatrices(tramat, emismat, symbols, alphabet)

def exam_viterbiLearning():
    lines = list(open('21_Baum_Welch_Learning.txt'))
    
    (iterations,x,alphabet,symbols,tramat,emismat) = parseLines(lines)
    tramat,emismat =  viterbiLearning(iterations,x,alphabet,symbols,tramat,emismat)
    
    printMatrices(tramat, emismat, symbols, alphabet)
    
if __name__ == '__main__':
    exam_viterbiLearning()